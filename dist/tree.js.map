{"version":3,"file":"tree.js","sources":["../src/errors.ts","../src/binarysearch.ts","../src/main.ts"],"sourcesContent":["export class NestedSetsError extends Error {\n    constructor(message:string) {\n        super(); \n        this.name = 'NestedSetsError'; \n        this.message = message; \n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            this.stack = (new Error()).stack;\n        }\n    }\n}; \n\nexport class NestedSetsValidationError extends Error {\n    constructor(message:string) {\n        super(); \n        this.name = 'NestedSetsValidationError'; \n        this.message = message; \n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            this.stack = (new Error()).stack;\n        }\n    }\n}; ","export default function(array:any[], target:number|string, key:string) {\n    let min:number = 0,\n        max:number = array.length - 1,\n        temp:number|string, mid:number;\n    while (min <= max) {\n        mid = Math.round(min + (max - min) / 2);\n        temp = array[mid] ? array[mid][key] : undefined;\n        if (temp === target) {\n            return array[mid];\n        } else if (temp < target) {\n            min = mid + 1;\n        } else {\n            max = mid - 1;\n        }\n    }\n}","import * as _ from 'lodash'; \nimport {NestedSetsError, NestedSetsValidationError} from \"./errors\";\nimport binarySearch from './binarysearch';\n\n\nexport interface CollectionEl {\n    [key:string]: number; \n};\nexport interface ExtremumResult {\n    index: number, \n    value: number,\n    el: CollectionEl\n}; \nexport interface Keys {\n    id?: string,\n    lvl?: string, \n    parentId?: string,\n    lft?: string, \n    rgt?: string, \n    hide?: string\n}; \nexport interface IndexedTree {\n    id?:CollectionEl[]\n};\nexport type stringOrNumberType = number | string;\n\n\nfunction getMinElByField(collection:CollectionEl[], field:string) :ExtremumResult {\n    let min :ExtremumResult = {\n        index: null, \n        value: null, \n        el: null \n    }; \n    collection.forEach((el, index, collection) => {\n        if (typeof el[field] !== \"number\") {\n            throw new NestedSetsError(`field ${field} does't exist in collection!`); \n        }\n\n        if (min.index === null || el[field] < min.value) {\n            min = {\n                index, \n                value: el[field], \n                el\n            }; \n        }\n\n    }); \n    return min; \n};\n\nfunction getMaxElByField(collection:CollectionEl[], field:string) :ExtremumResult {\n    let max :ExtremumResult = {\n        index: null, \n        value: null, \n        el: null\n    }; \n    collection.forEach((el, index, collection) => {\n        if (typeof el[field] !== \"number\") {\n            throw new NestedSetsError(`field ${field} does't exist in collection!`); \n        }\n\n        if (max.index === null || el[field] > max.value) {\n            max = {\n                index, \n                value: el[field], \n                el\n            }; \n        }\n    });\n    return max; \n}; \n\nexport default class NestedSets {\n    private _tree: CollectionEl[] = [];\n    get all():CollectionEl[] {\n        return this._tree;\n    }\n    get allIds():stringOrNumberType[] {\n        return _.map(this._tree, this._keys.id);\n    }\n    private _keys:Keys ={\n        id: 'id',\n        lvl: 'lvl',\n        parentId: 'parentId', \n        lft: 'lft', \n        rgt: 'rgt',\n        hide: 'hide' \n    };\n    get keys():Keys {\n        return this._keys; \n    }\n    set keys(keys: Keys) {\n        this._keys = keys;\n    } \n    private _indexes:IndexedTree = {\n        id: [],\n    };\n    public results: CollectionEl[] = []; \n    get ids():stringOrNumberType[] {\n        return _.map(this.results, this._keys.id);\n    }\n    constructor(keys: Keys) {\n        this._keys = Object.assign(this._keys, keys); \n    }\n\n    private _getElById(id: string|number):CollectionEl {\n        if (this._indexes.id && this._indexes.id.length) {\n            let el:CollectionEl = binarySearch(this._indexes.id, id, this._keys.id);\n            let p;\n            return el;\n        } else {\n            let searchObj = {};\n            searchObj[this._keys.id] = id;\n            return _.find(this._tree, searchObj); \n        }\n    }\n\n    public getElById(id: string|number):NestedSets {\n        let element = this._getElById(id);\n        this.results = element ? [element] : [];\n        return this; \n    }\n\n    public validate() {\n        NestedSets.validateTree(this._tree, this._keys); \n    }\n\n    public static validateTree(tree: CollectionEl[], keys:Keys) {\n        let lftrgt: number[] = []; //массив левых и правых индексов\n        \n        tree.forEach(el => {\n            if ((typeof el[keys.id]       !== 'number'  &&\n                    typeof el[keys.id]       !== 'string') ||\n                    typeof el[keys.hide]     !== 'boolean' ||\n                    typeof el[keys.lvl]      !== 'number'  ||\n                (typeof el[keys.parentId] !== 'number'  &&\n                    typeof el[keys.parentId] !== 'string') ||\n                    typeof el[keys.lft]      !== 'number'  ||\n                    typeof el[keys.rgt]      !== 'number') {\n                throw new NestedSetsValidationError('keys error!'); \n            }\n\n            if (!Number.isInteger(el[keys.lvl]) || el[keys.lvl] < 0  || \n                !Number.isInteger(el[keys.lft]) || el[keys.lft] <= 0 || \n                !Number.isInteger(el[keys.rgt]) || el[keys.rgt] <= 0 ) {\n                throw new NestedSetsValidationError('lvl, rgt, lft keys must be natural numbers!'); \n            }\n\n            if (el[keys.lft] >= el[keys.rgt]) {\n                throw new NestedSetsValidationError('every rgt key of element must be more than lft key!'); \n            }\t\n\n            if ( !((el[keys.rgt] - el[keys.lft]) & 1) ) {\n                throw new NestedSetsValidationError('the difference between the right and\\\n                    left index must be an odd number!'); \n            }\n\n            if (el[keys.lvl] & 1)  {\n                if (el[keys.lft] & 1) {\n                    throw new NestedSetsValidationError('For odd levels, the left index must be even!'); \n                }\n            }\n\n            if (!(el[keys.lvl] & 1))  {\n                if (!(el[keys.lft] & 1)) {\n                    throw new NestedSetsValidationError('For even levels, the left index must be odd!');\n                }\n            }\t\n\n            lftrgt.push(el[keys.lft]);\n            lftrgt.push(el[keys.rgt]);\n        });\n\n        lftrgt.sort((el1, el2) => {\n            return el1 - el2;\n        });\t\n\n        lftrgt.forEach((el, i, lftrgt) => {\n            if (lftrgt[i-1] === lftrgt[i]) {\n                throw new NestedSetsValidationError('The set of left and right indexes \\\n                    must be unique!');\n            }\n        });\n\n        let minLft:number = getMinElByField(tree, 'lft').value;\n        let maxRgt:number = getMaxElByField(tree, 'rgt').value;\n\n        if (minLft !== 1) {\n            throw new NestedSetsValidationError('The smallest left index must be equal to one!');\n        }\n        if (maxRgt !== tree.length*2) {\n            throw new NestedSetsValidationError('The largest right index must be equal \\\n                to twice the number of nodes!');\n        }\n\n\n    }\n\n    public loadTree(data: CollectionEl[], options?: {validate?:boolean, createIndexes?:boolean}, indexes?:IndexedTree) {\n        this._tree = data; \n        options = options || {};\n        const validate: boolean = options.validate !== undefined ? options.validate : false; \n        const createIndexes: boolean = options.createIndexes !== undefined ? options.createIndexes : false; \n\n        if (validate) {\n            this.validate(); \n        }\n\n        if (validate && indexes && indexes.id) {\n            NestedSets.validateTree(indexes.id, this._keys);\n        }\n\n        if (indexes && indexes.id.length) {\n            this._indexes.id = indexes.id;\n        }\n\n        if(createIndexes && (!indexes || !indexes.id || !indexes.id.length)) {\n            this._indexes.id = _.sortBy(data, [this._keys.id]);\n        }\n\n        return this; \n    }\n\n    public getRootCats() :NestedSets {\n        let rootCats:CollectionEl[] = this._tree.filter(el => {\n            return el[this._keys.lvl] === 1; \n        });\n        this.results = _.sortBy(rootCats, this._keys.lft);\n        return this;\n    }\n\n    public getRootEl() {\n        let results:CollectionEl[] = []; \n        for (let i = 0; i < this._tree.length; i++) {\n            let el:CollectionEl = this._tree[i];\n            if (el[this._keys.lvl] !== 0) continue; \n            results.push(el); \n            break;\n        } \n        this.results = results;\n        return this; \n    }\n    //статическая версия метода проверки на потомка без загрузки дерева\n    static isChild(parent:CollectionEl, child:CollectionEl, {lft, rgt}:Keys) :boolean {\n        return child[lft] > parent[lft] && \n            child[rgt] < parent[rgt];\t\t\n    }\n\n    public isChild(parent: CollectionEl, child: CollectionEl) :boolean {\n        return child[this._keys.lft] > parent[this._keys.lft] && \n            child[this._keys.rgt] < parent[this._keys.rgt];\n    }\n    \n    public checkKeys(el) {\n        let keys:Keys = this._keys; \n        if ((typeof el[keys.id]       !== 'number'  &&\n                typeof el[keys.id]       !== 'string') ||\n                typeof el[keys.lvl]      !== 'number'  ||\n                typeof el[keys.hide]     !== 'boolean' ||\n            (typeof el[keys.parentId] !== 'number'  &&\n                typeof el[keys.parentId] !== 'string') ||\n                typeof el[keys.lft]      !== 'number'  ||\n                typeof el[keys.rgt]      !== 'number') {\n\n            throw new NestedSetsValidationError('keys error!'); \n        }\n    }\n\n    private _normalizeElement(el:stringOrNumberType|CollectionEl):CollectionEl {\n        let element:CollectionEl; \n        if (typeof el === \"string\" || typeof el === \"number\") {\n            element = this._getElById(el);\n        } else {\n            element = el;\n        }\n        if (!element) throw new NestedSetsError('incorrect element!');\n        return element; \n    }\n    \n    public getChilds(el:stringOrNumberType|CollectionEl, hide:boolean):NestedSets {\n        let element:CollectionEl = this._normalizeElement(el); \n        let id:stringOrNumberType = element[this._keys.id]; \n        let results:CollectionEl[] = []; \n        //если у элемента правый ключ минус левый равен единицы - значит у него точно нет потомков \n        //и проходка по дереву не имеет смысла \n        if ((element[this._keys.rgt] - element[this._keys.lft] === 1)) {\n            this.results = [];\n            return this;  \n        }\n        \n        this._tree.forEach(el => {\n            //если исключать элементы нет нужды - проверяем parentKey\n            if (!hide && el[this._keys.parentId] === id) {\n                results.push(el);\n            }\n            //если исключать элементы есть необходимость, но данный элемент не отмечен флагом hide - включаем его в массив резудбьтатов\n            if (hide && !el[this._keys.hide] && el[this._keys.parentId] === id) {\n                results.push(el); \n            }\n        });\n\n        this.results = _.sortBy(results, [this._keys.lft]);\n        return this; \n    }\n\n    public isValidId(id:string|number):boolean {\n        let el:CollectionEl = this._getElById(id); \n        return !!el;\n    }   \n\n    public getAllChilds(el:stringOrNumberType|CollectionEl, hide:boolean):NestedSets {\n        let element:CollectionEl = this._normalizeElement(el); \n        let lft:number = element[this._keys.lft];\n        let rgt:number = element[this._keys.rgt]; \n        let results:CollectionEl[] = []; \n        //если у элемента правый ключ минус левый равен единицы - значит у него точно нет потомков \n        //и проходка по дереву не имеет смысла \n        if ((element[this._keys.rgt] - element[this._keys.lft] === 1)) {\n            this.results = [];\n            return this;  \n        }     \n\n        this._tree.forEach(el => {\n            if (!hide && el[this._keys.lft] >= lft && el[this._keys.rgt] <= rgt) {\n                results.push(el);\n            }\n            if (hide && !el[this._keys.hide] && el[this._keys.lft] >= lft && el[this._keys.rgt] <= rgt) {\n                results.push(el); \n            }\t            \n        }); \n\n        this.results = _.sortBy(results, [this._keys.lft]);\n        return this; \n    }\n\n    public getDepth():number {\n        let depth:number = 0; \n        this._tree.forEach(el => {\n            if (el[this._keys.lvl] > depth) {\n                depth = el[this._keys.lvl];\n            }\n        });\n        return depth;\n    }\n\n    public getParent(el:stringOrNumberType|CollectionEl):NestedSets {\n        let element:CollectionEl = this._normalizeElement(el); \n        let parentId:stringOrNumberType = element[this._keys.parentId];\n        let depth:number = element[this._keys.lvl];\n        let results:CollectionEl[] = [];\n\n        if (!depth) {\n            results = []; \n        } else {\n            let parent:CollectionEl = this._getElById(parentId);\n            results.push(parent);\n        }\n        this.results = results;\n        return this;\n    }\n\n    public getAllParents(el:stringOrNumberType|CollectionEl, hide:boolean):NestedSets {\n        let element:CollectionEl = this._normalizeElement(el); \n        let lft = element[this._keys.lft];\n        let rgt = element[this._keys.rgt]; \n        let results:CollectionEl[] = []; \n\n        this._tree.forEach(el => {\n            if (!hide && el[this._keys.lft] <= lft && el[this._keys.rgt] >= rgt) {\n                results.push(el);\n            }\n\n            if (hide && !el[this._keys.hide] && el[this._keys.lft] <= lft && el[this._keys.rgt] > rgt) {\n                results.push(el);\n            }\t\t\t\n        });\n        this.results = _.sortBy(results, this._keys.lvl);\n        return this;\n    }; \n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],"names":["message","name","Error","captureStackTrace","constructor","stack","array","target","key","min","max","length","temp","mid","Math","round","undefined","collection","field","forEach","el","index","NestedSetsError","value","keys","_keys","Object","assign","id","_indexes","binarySearch","searchObj","_","_tree","element","_getElById","results","validateTree","data","options","indexes","validate","createIndexes","rootCats","filter","lvl","lft","i","push","parent","child","rgt","hide","parentId","NestedSetsValidationError","_normalizeElement","depth","tree","lftrgt","Number","isInteger","sort","el1","el2","minLft","getMinElByField","maxRgt","getMaxElByField"],"mappings":"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"}